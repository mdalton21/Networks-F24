## Assign militia status to nodes ------------------------------
V(main_graph)$militia <- ifelse(V(combined_graph)$name %in% militias, 1, 0)
## -------------------------------------
## Add aggressiveness attribute
## -------------------------------------
## Convert the graph to a dataframe ------------------------------
temp_vector <- as_data_frame(main_graph) %>%
as_tibble() %>%
select(from) %>%
## Merge the vertices with the the aggression data for sending actors
left_join(drugnet %>%
select(sideA, agression) %>%
distinct(),
by = c("from" = "sideA")) %>%
distinct(from, agression) %>%
## Add the sideB actors to the dataframe.
full_join(drugnet %>%
select(sideB, agression) %>%
distinct(),
by = c("from" = "sideB")) %>%
select(-agression.y) %>%
rename("agression" = agression.x) %>%
distinct(from, agression) %>%
select(agression) %>%
## Codes actors that never directed an attack as having an aggression of 0
mutate(agression = ifelse(is.na(agression), 0, agression)) %>%
ungroup() %>%
pull()
## Assign aggression scores to vertices ------------------------------
V(main_graph)$aggression <- temp_vector
## -------------------------------------
## Add subfaction attribute
## -------------------------------------
subfaction <- vector(length = 151, mode = "numeric")
## The indices of groups that are subfactions ------------------------------
subfaction[c(8, 72, 74, 75, 77:79, 113, 134, 136:138, 142:146, 148, 149)] <- 1
V(main_graph)$subfaction <- subfaction
## -------------------------------------
## Create time period before and after arrest
## -------------------------------------
## Create a vector of periods in which each tie existed ------------------------------
period <- drugnet %>%
mutate(period = ifelse(year < 2017, 1, 2)) %>%
group_by(period, sideA, sideB) %>%
ungroup() %>%
distinct(sideA, sideB, period) %>%
group_by(sideA, sideB) %>%
summarise(period = max(period)) %>%
ungroup() %>%
pull(period)
## Add a year attribute to the combined graph ------------------------------
E(main_graph)$period <- period
## Split into two graphs for pre and post arrest ------------------------------
preNet <- subgraph.edges(main_graph, E(main_graph)[E(main_graph)$period < 2])
postNet <- subgraph.edges(main_graph, E(main_graph)[E(main_graph)$period > 1])
# Dyad and Triad Census -----------------------------------------------
igraph::dyad_census(preNet) # some one-way relationships, but mostly sparse
igraph::dyad_census(postNet) # couple reciprocal relationships, still mostly sparse
igraph::triad_census(preNet) # mostly empty triads
igraph::triad_census(postNet) # mostly empty triads, but some 012 and 102
## -------------------------------------
## Preferential Attachment
## -------------------------------------
drug_EL <- as_data_frame(main_graph, what = "edges")
drug_EL <- drug_EL %>%
mutate(from = as.numeric(as.factor(from)),  # converting side names to unique IDs
to = as.numeric(as.factor(to)))
drug_PAFit <- as.PAFit_net(as.matrix(drug_EL))
result_OS <- PAFit_oneshot(drug_PAFit)
summary(result_OS)
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods[[i]] <- modularities
# Convert list to a data frame for easy comparison
mod_df <- do.call(rbind, all_mods)
colnames(mod_df) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(mod_df)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods[[i]] <- modularities
# Convert list to a data frame for easy comparison
mod_df <- do.call(rbind, all_mods)
colnames(mod_df) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(mod_df)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
all_mods <- list()  # List to hold modularity for network
compare_modularity <- function(graph) {
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods[[i]] <- modularities
# Convert list to a data frame for easy comparison
mod_df <- do.call(rbind, all_mods)
colnames(mod_df) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(mod_df)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods[i] <- modularities
# Convert list to a data frame for easy comparison
mod_df <- do.call(rbind, all_mods)
colnames(mod_df) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(mod_df)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods <- modularities
# Convert list to a data frame for easy comparison
mod_df <- do.call(rbind, all_mods)
colnames(mod_df) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(mod_df)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
modularities
infomap <- cluster_infomap(main_graph)
modularity(infomap)
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
#all_mods <- modularities
# Convert list to a data frame for easy comparison
mod_df <- do.call(rbind, modularities)
colnames(mod_df) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(mod_df)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
lead_eig <- cluster_leading_eigen(main_graph)
c(
modularity(infomap),
modularity(lead_eig))
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods <- modularities
# Convert list to a data frame for easy comparison
#mod_df <- do.call(rbind, all_mods)
colnames(mod_df) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(mod_df)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods <- modularities
# Convert list to a data frame for easy comparison
#mod_df <- do.call(rbind, all_mods)
colnames(all_mods) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(all_mods)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods <- modularities
# Convert list to a data frame for easy comparison
#mod_df <- do.call(rbind, all_mods)
#colnames(all_mods) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(all_mods)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
mod_df
drugMods
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods <- modularities
# Convert list to a data frame for easy comparison
#mod_df <- do.call(rbind, all_mods)
rownames(all_mods) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
mod_df <- data.frame(all_mods)
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
## -------------------------------------
## Community Detection
## -------------------------------------
# Comparing Modularities -----------------------------------------------
compare_modularity <- function(graph) {
all_mods <- list()  # List to hold modularity for network
# Compute each clustering method
infomap <- cluster_infomap(graph)            # Infomap
lead_eig <- cluster_leading_eigen(graph)     # Leading Eigenvector
label_prop <- cluster_label_prop(graph)       # Lable Prop
walktrap <- cluster_walktrap(graph)          # Walktrap
# Store the modularity for each method
modularities <- c(
modularity(infomap),
modularity(lead_eig),
modularity(label_prop),
modularity(walktrap)
)
# Store modularities for this graph
all_mods <- modularities
# Convert list to a data frame for easy comparison
#mod_df <- do.call(rbind, all_mods)
mod_df <- data.frame(all_mods)
rownames(mod_df) <- c("Infomap", "Leading Eigenvector", "Spinglass", "Walktrap")
return(mod_df)
}
drugMods <- compare_modularity(main_graph) # Infomap performs the best!
drugMods
drugMods <- compare_modularity(preNet) # Infomap performs the best!
drugMods
drugMods <- compare_modularity(postNet) # Infomap performs the best!
drugMods
knitr::kable(drugMods, booktabs = TRUE)
knitr::kable(drugMods, booktabs = TRUE, digits=3,
col.names = "")
## Create table of modularity scores -----------------------------------------------
mods_tab <- knitr::kable(drugMods, booktabs = TRUE, digits=3, format = "latex",
table.envir = "table", position = "!h",
col.names = "",
caption="Modularity Scores")
writeLines(mods_tab, file.path(fig_dir, 'mods_tab.tex')) ## save
# Network Plot at t=1 (2012)
plot(drug_PAFit, slice = 1,
arrowhead.cex = 2, vertex.cex = 3,
vertex.col=color,
main="Figure 7a. Network at t=1 (2012)")
# Network Plot at t=1 (2020)
plot(drug_PAFit, slice = 9,
arrowhead.cex = 2, vertex.cex = 3,
vertex.col=color,
main="Figure 7b. Network at t=9 (2020)")
drug_PAFit
# Network Plot at t=1 (2020)
plot(drug_PAFit, slice = 2,
arrowhead.cex = 2, vertex.cex = 3,
vertex.col=color,
main="Figure 7b. Network at t=9 (2020)")
# Network Plot at t=1 (2012)
plot(drug_PAFit, slice = 0,
arrowhead.cex = 2, vertex.cex = 3,
vertex.col=color)
# Network Plot at t=1 (2020)
plot(drug_PAFit, slice = 1,
arrowhead.cex = 2, vertex.cex = 3,
vertex.col=color)
# Network Plot at t=0 (pre-2017)
png(file.path(fig_dir, "pre_PA.png"), res=100)
plot(drug_PAFit, slice = 0,
arrowhead.cex = 2, vertex.cex = 3,
vertex.col=color)
dev.off()
# Network Plot at t=1 (post-2017)
png(file.path(fig_dir, "post_PA.png"), res=100)
plot(drug_PAFit, slice = 1,
arrowhead.cex = 2, vertex.cex = 3,
vertex.col=color)
dev.off()
# Preferrential Attachment Table -----------------------------------------------
result_OS <- PAFit_oneshot(drug_PAFit)
summary(result_OS)
knitr::kable(result_OS)
screenreg(result_OS)
summary(result_OS)
result_OS$alpha
PA_tab <- c("Estimated Attachment", result_OS$alpha)
PA_tab
knitr::kable(result_OS$alpha)
knitr::kable(result_OS$alpha, booktabs = TRUE, digits=3)
knitr::kable(result_OS$alpha, booktabs = TRUE, digits=3,
col.names = "")
PA_tab <- knitr::kable(result_OS$alpha, booktabs = TRUE, digits=3, format = "latex",
table.envir = "table", position = "!h",
col.names = "",
caption="Modularity Scores")
writeLines(PA_tab, file.path(fig_dir, 'PA_tab.tex')) ## save
summary(result_OS)
result_OS$upper_A
result_OS$ci
tab <- (result_OS$alpha, result_OS$ci)
tab <- c(result_OS$alpha, result_OS$ci)
tab
knitr::kable(tab, booktabs = TRUE, digits=3, format = "latex",
table.envir = "table", position = "!h",
col.names = c("Estimated Attachment", "CI Low", "CI High"),
caption="Preferential Attachment")
knitr::kable(tab, booktabs = TRUE, digits=3,
col.names = c("Estimated Attachment", "CI Low", "CI High"))
knitr::kable(tab, booktabs = TRUE, digits=3,
col.names = c("Estimated Attachment", "Confidence Intervals"),
caption="Preferential Attachment")
colnames(tab)
rownames(tab)
tab
tab <- as.dataframe(c(result_OS$alpha, result_OS$ci))
tab <- as.data.frame(c(result_OS$alpha, result_OS$ci))
colnames(tab)
knitr::kable(tab)
tab <- as.data.frame(rbind(result_OS$alpha, result_OS$ci))
colnames(tab)
tab
tab <- rbind(result_OS$alpha, result_OS$ci)
tab
tab <- cbind(result_OS$alpha, result_OS$ci)
tab
knitr::kable(result_OS$alpha)
PA_tab <- knitr::kable(result_OS$alpha, booktabs = TRUE, digits=3, format = "latex",
table.envir = "table", position = "!h",
col.names = NULL,
caption="Preferential Attachment")
writeLines(PA_tab, file.path(fig_dir, 'PA_tab.tex')) ## save
## Create table of modularity scores -----------------------------------------------
mods_tab <- knitr::kable(drugMods, booktabs = TRUE, digits=3, format = "latex",
table.envir = "table", position = "!h",
col.names = NULL,
caption="Modularity Scores")
writeLines(mods_tab, file.path(fig_dir, 'mods_tab.tex')) ## save
# Distribution of degree centrality at t=0 (pre-2017)
plot(drug_PAFit, slice = 1, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1)
# Distribution of degree centrality at t=0 (pre-2017)
plot(drug_PAFit, slice = 0, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1)
# Distribution of degree centrality at t=0 (pre-2017)
hist(drug_PAFit, slice = 0, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1)
drug_PAFit
# Distribution of degree centrality at t=0 (pre-2017)
plot(drug_PAFit, slice = 0, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1)
# Distribution of degree centrality at t=9 (2020)
plot(drug_PAFit, slice = 1, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1)
plot(drug_PAFit, slice = 0, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1,
xlab="")
plot(drug_PAFit, slice = 0, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1,
x="")
?plot
plot(drug_PAFit, slice = 0, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1,
xlab=NULL)
plot(drug_PAFit, slice = 0, plot = "degree", cex = 2, cex.axis = 1,
xlab=NULL)
png(file.path(fig_dir, "pre_PA_deg.png"), res=100)
plot(drug_PAFit, slice = 0, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1)
dev.off()
# Distribution of degree centrality at t=9 (2020)
png(file.path(fig_dir, "post_PA_deg.png"), res=100)
plot(drug_PAFit, slice = 1, plot = "degree", cex = 2, cex.axis = 1, cex.lab = 1)
dev.off()
